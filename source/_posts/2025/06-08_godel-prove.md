---
title: 哥德尔不完备性定理
permalink: post/84/
excerpt: <!-- -->
date: 2025-06-08 18:17:35
tags:
---

“所有的真理都能被证明”是一个非常自然的想法。但是，至少在基础算术中，不是所有的真命题都能被证明出来。说明这一现象的就是哥德尔不完备性定理。

哥德尔不完备性定理是数学领域内最反直觉的定理之一：即使是（几乎）最简单的数学系统——基础算术（即自然数（0和正整数）的加减乘运算，小学2年级数学），也复杂到不完备，即存在真命题，无法被证明。

哥德尔不完备性定理的证明过程极为巧妙，理论上来说，它只需要小学数学和一点逻辑学知识就能理解。不幸的是，我在阅读相关资料时，发现大部分科普文章给出的证明过程要么又臭又长，要么过于晦涩难懂。于是，我决定写一篇文章，尽量详细且简洁地解释哥德尔不完备性定理的证明过程。

<br>

### 哥德尔不完备性定理

哥德尔不完备性定理一共有两条：

哥德尔第一不完备性定理：如果⽪亚诺算术公理没有⽭盾，那么存在这样⼀个算术命题，它是真的，但不能通过算术公理证明出来。

哥德尔第二不完备性定理：如果⽪亚诺算术公理没有⽭盾，那么算术公理没有⽭盾这个命题本⾝不可能通过算术公理证明出来。

<br>

这其中，皮亚诺算术公理是定义了基础算术的公理系统，一共有5条，分别是：

1. 0 是自然数；
2. 每个自然数n都有一个后继数（通常记作 S(n) 或 n+1 ，表示n的下一个自然数）；
3. 0 不是任何自然数的后继数；
4. 对于每个自然数 m 和 n ，m=n 当且仅当 m+1 = n+1；
5. 如果一个性质对 0 成立，假设其对 n 成立，可以证明其也对 S(n) 成立，那么这个性质对所有自然数都成立。（即数学归纳法成立）

<br>

用更严谨的数学语言来描述哥德尔不完备性定理，就是：

只要一个公理系统（即，用规定好的符号，和一些起始公理和推理规则定义的数学系统。欧氏几何，皮亚诺算术公理等都是公理化系统）强大到足够表达基础算术（即，可以表达自然数的加法，乘法，相等，和存在/全称量词），且这个系统是一致的（即不存在一个命题，既可以被证明为真，又可以被证明为假），那么这个系统就一定是不完备的，即存在某个命题，既不能被证明为真，也不能被证明为假。

且，无法在上述系统内部证明本系统是一致的。

<br>

### 第一不完备性定理的证明

#### 1. 命题的可编码性

**在皮亚诺算术公理下，存在一种编码方法，可以将任何一个命题转换为一个自然数。**

证明如下：

首先，**总可以将每个符号（如数字，运算符，括号等）映射到一个唯一的自然数。**

无论什么系统，符号的数量总是有限的，比如皮亚诺算术公理系统一共只有12个符号：
- ~（非）
- ∨（或）
- ⊃（如果...那么...）
- ∃（存在）
- =（等于）
- 0（零）
- S（后继）
- (（左括号）
- )（右括号）
- ,（逗号）
- +（加）
- ×（乘）

再加上一些变量符号（如 x，y，z 等）。

<br>

然后，**总可以将一个命题的符号序列转换为一个自然数序列。**

比如说，这12个符号可以被编码为自然数 1 到 12。x，y，z等变量符号通常用12之后的素数编码：13，17，19...。

比如，命题 ~(Sx=0)（“x 的后继数不等于 0”，即 “0 不是任何自然数的后继数”）

就可以被编码为一个自然数序列：{1, 8, 13, 5, 9}。

注：使用素数是为了简化一些描述。事实上，完全可以使用13，14，15...等自然数来编码变量符号。

<br>

最后，**总可以将这个自然数序列编码为一个单一的自然数**，比如通过将每个数字作为一个质因数的指数。

对于自然数序列{1, 8, 13, 5, 9}，其对应的编码自然数为 2^1 * 3^8 * 5^13 * 7^5 * 11^9。此数字也被称为此命题的“哥德尔数”。

<br>

#### 2. 证明过程的可编码性

**存在一种编码方法，可以将任何一个证明过程转换为一个自然数。**

其思路与上文类似，证明如下：

因为总可以将任何一个命题转换为一个自然数，而任何一个命题的证明过程本质上就是一系列有限且有序的命题，第一个命题是公理，最后一个命题是要证明的结论。所以，一个证明的命题序列可以转换为一个自然数序列，并最终编码为一个自然数。

比如，命题 ∃x (x=S0) （“存在 0 的后继（即 1 ）”）的证明过程为：

- ∃x (x=Sy)
- ∃x (x=S0)

设这两步证明的哥德尔数分别为 A 和 B，那么这个证明过程可以被编码为一个自然数序列 {A, B}，并最终编码为一个自然数 2^A * 3^B。

<br>

#### 3. 程序的可编码性

**存在一种编码方法，可以将任何一个程序转换为一个自然数。**

因为任何一个程序都是有限长的字符序列，而字符序列可以被编码为自然数（证明见上）。因此，任何一个程序都可以被编码为一个自然数。

由于图灵机，算法和程序等价，所以也可以被编码为一个自然数。鉴于非数学/计算机科学的读者可能不太熟悉图灵机的概念，本文将用“程序”一词来代替。

<br>

#### 4. 枚举式判定算法

**存在通用的可以证明所有存在证明的命题的算法。**

证明如下：

在数学证明中，推理规则一共只有2条：肯定前件（由 ϕ 与 ϕ → ψ 推出 ψ）和全称化（由 ϕ 推出 ∀x ϕ）。

所以，判断一个证明过程是否有效，只需要判断每一步得到的推论是否符合语法，且是否可以由推理规则 从公理和之前的推论中推出。这些工作均可以在有限步骤内完成。

<br>

剩下的工作就简单了：因为每一个证明过程都可以被编码为一个自然数（证明见上），所以可以从1开始，依次暴力枚举所有自然数，检查其对应的证明过程是否是对此命题的有效证明。只要这个命题是可以被证明的，那么总有一个自然数对应的证明过程会被找到。

这说明，存在一个算法（暴力枚举+验证有效），可以在有限步骤内证明任何可以证明的命题。记这个算法为 K。

注：对于不可证明的命题，此方法会永远运行下去。

<br>

#### 5. 停机问题

**不存在一个通用的算法，能够在有限步内，判断任意程序M与输入x是否停机。**

注1：“停机”指的是程序会在有限步内停止运行。反之，则称其“进入死循环”。

注2：“程序 M 的输入为 x”在本段中记作 M(x) 。

使用反证法：

假设存在一个通用程序 U(M, x)，能够判断任意程序 M 在输入 x 时是否会停机。

让我们依据这个程序 U 构造另一个程序 N(Y)：如果 U 判断 Y(Y) 会停机，那么 N 就进入死循环；如果 U 判断 Y(Y) 进入死循环，那么 N 就立刻停机。

注3：Y是一个程序，但也可以被编码为一个自然数（证明见上），所以也可以作为程序的合法输入。

现在考虑这个命题： N(N) 是否会停机。

如果通用程序 U 判断 N(N) 会停机，那么 N(N) 就会进入死循环；反之，如果算法 U 判断 N(N) 不会停机，那么 N(N) 就会立刻停机。无论如何，通用程序 U 都会给出错误的判断。

因此，程序 U 不可能存在，即不存在任何方法，能够在有限步内判断任意一个程序会不会停机。

<br>

更进一步，假设存在一个万能算法 V(x)，能够判断任意一个算术命题 x 是否为真。

考虑以下命题：程序 M 在输入 x 时会停机。

如果 V 能够判断这个命题为是否真，那么 V 就可以充当判断程序是否停机的通用算法 U 。但是，上文中已经证明不存在通用算法 U ，所以 V 不可能存在。即，不存在一个通用的算法 V，能够判断任意一个算术命题是否为真。

<br>

#### 6. 第一不完备性定理的一种证明

**任何 “足够表达整数加减乘的公理体系 T” 只要保持一致，就不可能把每一句算术命题都判定出“真”或“假”。**

使用反证法，假设公理体系 T 一致，完备，又ω-一致（即它的每条定理都在自然数中成立）。那么就可以使用枚举算法K，通过枚举，同时开始证明任意算术命题 A 和 非A 。

因为 T 是一致的，A 和 非A 总有一个为真。不妨设 A 为真。

因为 T 是完备的，所以 A 一定能被证明，那么 枚举算法 K 一定可以在有限步内证明 A 命题。

这说明，对任意算术命题，总有方法能在有限步内给出正确判断。但这与上文中证明的“不存在通用算法 V 能够判断任意一个算术命题是否为真”矛盾。

因此，假设不成立。如果 T 是一致的，那么 T 一定是不完备的，即存在某个算术命题，既不能被证明为真，也不能被证明为假。

<br>

#### 7. 第一不完备性定理的另一种证明

**存在⼀个算术命题，它是真的，但不能证明出来。**

首先，定义一个函数 sub(a,b,c)。此函数的作用是：取哥德尔数为 a 的命题，找到命题中哥德尔数为 c 的符号的位置，把它替换成数字 b ，并计算新命题的哥德尔数。

比如，对于命题 0=0，其哥德尔数为 2^6 * 3^5 * 5^6 = 243000000。

那么，sub(243000000,0,5)的含义就是：取哥德尔数为 243000000 的命题（即 “0=0” ），找到命题中哥德尔数为 5 的符号（即 “=”号），替换成“0”。最终得到的新“命题”是 000 。其哥德尔数为 2^6 * 3^6 * 5^6 = 729000000。

<br>

考虑此命题：“无法证明哥德尔数是 sub(y,y,17) 的命题”，设此命题的哥德尔数为 n 。

想要知道“哥德尔数是 sub(y,y,17) 的命题”是什么，首先，取哥德尔数为 y 的命题：假设y的值是 10^100，假设以 10^100 为哥德尔数的命题为 (∃ x )( x = sy )。

在此命题中，找到哥德尔数为 17 的符号（即 “y” 符号），并将其替换为 10^100 ，得到新的命题：(∃ x )( x = s10^100 )

那么，以 sub(y,y,17) 即 sub(10^100,10^100,17) 为哥德尔数的命题就是 (∃ x )( x = s10^100 )

<br>

现在，考虑此命题：“无法证明哥德尔数是 sub(n,n,17) 的命题”，记此命题为 G。

想要知道“哥德尔数是 sub(n,n,17) 的命题”是什么，首先，取哥德尔数为 n 的命题，即 “无法证明哥德尔数是 sub(y,y,17) 的命题”。

然后，找到哥德尔数为 17 的符号（即 “y” 符号），并将其替换为 n ，得到新的命题：“无法证明哥德尔数是 sub(n,n,17) 的命题”，即 G 本身。

如此，我们通过复杂的方式，构造了一个命题，其哥德尔数存在在它本身中。

<br>

假如“无法证明哥德尔数是sub(n,n,17)的命题”是一个假命题，则说明 可以证明哥德尔数是sub(n,n,17)的命题，所以哥德尔数是sub(n,n,17)的命题是一个真命题，即“无法证明哥德尔数是sub(n,n,17)的命题”是一个真命题，与原假设矛盾。

所以，如果承认皮亚诺算术公理系统是一致的，那么“无法证明哥德尔数是sub(n,n,17)的命题”就只能是一个真命题。

但由于它说自己是无法证明的，所以这就是一个无法被证明出来的真命题。存在⼀个算术命题，它是真的，但不能证明出来。

<br>

### 第二不完备性定理的证明

**任何 “足够表达整数加减乘的公理体系 T” 只要保持一致，就不可能证明本体系的一致性。**

第一不完备性定理证明了：如果 “T 是一致的”，那就一定找不到 G 的证明。此时，由于 G 说自己是无法证明的，所以 G 是真的。即，“T 是一致的” 证明了 G 。

假设 T 能证明 “T 是一致的” ，那么 T 就能证明 G ，这就与第一不完备性定理矛盾。

所以，T 不能证明 “T 是一致的” ，即，T 没有⽭盾这个命题本⾝不可能通过 T 证明出来。

<br>

---

附录：程序N(Y)的代码化表述

```python
def N(Y):
    if U(Y, Y) == False:  # 如果通用算法 U 判断 Y(Y) 不会停机
        return True  # 则 N(Y) 停机
    else:
        while True:  # 否则进入死循环
            pass
```
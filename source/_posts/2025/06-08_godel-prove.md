---
title: 哥德尔不完备性定理
permalink: post/84/
excerpt: <!-- -->
date: 2025-06-08 18:17:35
tags:
---

### 前言

“总有办法知道每句话是真是假”，和“所有的真理都能被证明”，是非常自然的想法。但是，至少在基础算术中，不是所有的命题都能判断真假，且不是所有的真命题都能被证明出来。说明这一现象的就是哥德尔不完备性定理。

哥德尔不完备性定理是数学领域内最反直觉的定理之一：即使是（几乎）最简单的数学系统——基础算术（即自然数（0和正整数）的加减乘运算，小学2年级数学），也复杂到 有无法被证明的真命题。

哥德尔不完备性定理的证明过程极为巧妙，理论上来说，它的思路只需要小学数学和一点逻辑学知识就能理解。但大部分科普文章给出的证明过程要么又臭又长，要么过于专业而晦涩难懂。于是，我决定写一篇文章，尽量严谨，详细且简洁地用白话解释哥德尔不完备性定理的证明过程。

<br>

### 不完备性定理的表述

哥德尔不完备性定理一共有两条：

哥德尔第一不完备性定理：如果⽪亚诺算术公理没有⽭盾，那么存在这样⼀个算术命题，它是真的，但不能通过算术公理证明出来。

哥德尔第二不完备性定理：如果⽪亚诺算术公理没有⽭盾，那么算术公理没有⽭盾这个命题本⾝不可能通过算术公理证明出来。

<br>

这其中，皮亚诺算术公理是定义了基础算术（即最简单的算术，包括自然数的加，减，乘运算）的公理系统，一共有5条，分别是：

1. 0 是自然数；
2. 每个自然数n都有一个后继数（通常记作 S(n) 或 n+1 ，表示n的下一个自然数）；
3. 0 不是任何自然数的后继数；
4. 对于每个自然数 m 和 n ，m=n 当且仅当 m+1 = n+1；
5. 如果一个性质对 0 成立，假设其对 n 成立，可以证明其也对 S(n) 成立，那么这个性质对所有自然数都成立。（即数学归纳法成立）

<br>

用更严谨的数学语言来描述哥德尔不完备性定理，就是：

只要一个公理系统（即，用规定好的符号，和一些起始公理和推理规则定义的数学系统。欧氏几何，皮亚诺算术公理等都是公理化系统）强大到足够表达基础算术，且这个系统是一致的（即不存在一个命题，既可以被证明为真，又可以被证明为假），那么这个系统就一定是不完备的（即 存在某个命题，既不能被证明为真，也不能被证明为假，也即 不是所有的真命题都能被证明出来）。

且，无法在上述系统内部证明本系统是一致的。

<br>

### 第一不完备性定理的证明

设 公理体系 T 能够描述自然数的加、减、乘运算（即至少包含皮亚诺算术作为其子系统）。除非另有说明，下文的所有证明都在公理系统 T 中进行。

<br>

#### 1. 命题的可编码性

**存在一种编码方法，可以将任何一个命题转换为一个自然数。**

证明如下：

首先，**总可以将每个符号（如数字，运算符，括号等）映射到一个唯一的自然数。**

（可递推的）系统中，构成命题的符号的数量总是有限的，比如公理体系 T 一共只有12个运算符号：

- ~（非）
- ∨（或）
- ⊃（如果...那么...）
- ∃（存在）
- =（等于）
- 0（零）
- S（后继）
- (（左括号）
- )（右括号）
- ,（逗号）
- +（加）
- ×（乘）

再加上一些变量符号（如 x，y，z 等）。

<br>

然后，**总可以将一个命题的符号序列转换为一个自然数序列。**

比如说，这12个运算符号可以被编码为自然数 1 到 12。x，y，z等变量符号通常用12之后的素数编码：13，17，19...。

注：使用素数是为了简化后续描述。事实上，完全可以使用13，14，15...等自然数来编码变量符号。

比如，命题 ~(Sx=0)（“x 的后继数不等于 0”，即 “0 不是任何自然数的后继数”）

就可以被编码为一个自然数序列：{1, 8, 13, 5, 9}。

<br>

最后，**总可以将这个自然数序列编码为一个单一的自然数**，比如通过将每个数字作为一个质因数的指数。

对于自然数序列{1, 8, 13, 5, 9}，其对应的编码自然数为 2^1 * 3^8 * 5^13 * 7^5 * 11^9，即634796401646829484863281250。此数字被称为此命题的“哥德尔数”。

<br>

#### 2. 证明过程的可编码性

**存在一种编码方法，可以将任何一个证明过程转换为一个自然数。**

其思路与上文类似，证明如下：

任何一个命题的证明过程本质上就是一系列有限且有序的命题，第一个命题是公理，最后一个命题是要证明的结论，而总可以将任何一个命题转换为一个自然数。所以，一个证明的命题序列可以被编码为一个自然数序列，并最终编码为一个自然数。

比如，命题 (∃x)(x=S0) （“存在 0 的后继（即 1 ）”）的证明过程为：

- (∃x)(x=Sy)
- (∃x)(x=S0)

设这两个命题的哥德尔数分别为 y 和 z（它们都是非常大的数，见附录），那么这个证明过程可以被编码为一个自然数序列 {y, z}，并最终编码为一个自然数 2^y * 3^z。

<br>

#### 3. 程序的可编码性

**存在一种编码方法，可以将任何一个程序转换为一个自然数。**

证明如下：

因为任何一个程序都是有限种类的字符的有限长序列，而字符序列可以被编码为自然数（证明见上）。因此，任何一个程序都可以被编码为一个自然数。

<br>

由于程序/算法/图灵机均为 能以有限步骤、以机械的方式计算出结果的有效过程，所以在计算理论中，程序/算法/图灵机这三个概念等价，即，总可以写出一个执行某算法的图灵机，也总可以构建一个执行某算法的程序。

鉴于非数学/计算机科学的读者可能不太熟悉图灵机的概念，本文将用“程序”或“算法”代替“图灵机”一词，来稍微增加一点直观性。

除非另有说明，下文的所有“程序”和“算法”均是指 有限长，输入为自然数，且内部具有有限个状态的程序（本质上就是图灵机）。

<br>

#### 4. 枚举式证明算法

**存在通用的可以证明所有存在证明的命题的算法。**

证明如下：

在数学证明中，推理规则一共只有2条：肯定前件（由 ϕ 与 ϕ → ψ 推出 ψ ）和全称化（由 ϕ 推出 ∀x ϕ ）。

所以，判断一个证明过程是否有效，只需要判断每一步得到的推论是否符合语法，且是否可以由推理规则 从公理和之前的推论中推出。这些工作只是简单的枚举，故可以在有限步骤内机械地完成。

<br>

剩下的工作就简单了：因为每一个证明过程都可以被编码为一个自然数（证明见上），所以可以从2开始，依次暴力枚举所有自然数，检查其对应的证明过程是否是对此命题的有效证明。只要这个命题是可以被证明的，那么总有一个自然数对应的证明过程会被找到。

注：对于为假或不可证明的命题，此方法会永远运行下去，永远不会停止。

这说明，存在一个算法（暴力枚举+逐步验证），可以在有限步骤内证明任何可以证明的命题。即，只要一个命题可以被证明，就可以使用此算法找到其证明方法。

<br>

#### 5. 停机问题

**不存在一个通用的算法，能够在有限步内，判断任意程序 M 与输入 x 是否停机。**

注：“停机”指的是程序会在有限步内停止运行。

使用反证法：

假设存在一个通用算法 U(M, x)，能够判断任意程序 M 在输入为 x 时（下文记作M(x)）是否会停机。

让我们依据这个算法 U 构造另一个程序 N(Y)：如果 U 判断 Y(Y) 会停机，那么就让 N 进入死循环；如果 U 判断 Y(Y) 进入死循环，那么就让 N 立刻停机。N的代码化表述见附录。

注2：Y 是一个程序，但也可以被编码为一个自然数（证明见上），所以也可以作为程序的合法输入。

现在考虑这个命题：N(N) 是否会停机。

如果通用算法 U 判断 N(N) 会停机，那么 N(N) 就会进入死循环；反之，如果算法 U 判断 N(N) 不会停机，那么 N(N) 就会立刻停机。无论如何，通用算法 U 都会给出错误的判断。

因此，通用算法 U 不可能存在，即不存在任何通用方法，能够在有限步内判断任意一个程序会不会停机。

<br>

更进一步，假设存在一个通用算法 V(y)，能够判断任意一个算术命题 y 是否为真。

考虑以下命题 y：M(x) 会停机。

如果 V 能够判断这个命题为是否真，那么 V 就可以充当判断程序是否停机的通用算法 U 。但是，上文中已经证明不存在通用算法 U ，所以 V 不可能存在。即，不存在一个通用的算法 V，能够判断任意一个算术命题是否为真。

<br>

#### 6. 第一不完备性定理的一种证明

**只要公理体系 T 是一致的，则总存在某个算术命题，既不能被证明为真，也不能被证明为假。**

使用反证法，假设公理体系 T 一致，完备，且它的每条定理都在自然数中成立（称作 ω-一致）。那么就可以使用 暴力枚举+逐步验证 的方法，同时开始证明任意算术命题 A 和非 A 。

因为 T 是一致的，A 命题 和非 A 命题总有一个为真。不妨设 A 命题为真。

因为 T 是完备的，所以 A 命题一定能被证明，那么 总可以使用 暴力枚举+逐步验证 的方法，在有限步内证明 A 命题。A 命题被证明为真，则非 A 命题也立即被证明为假。

由于算术命题 A 是任取的，这说明，对任意算术命题，总有方法能在有限步内给出正确判断。但这与上文中证明的“不存在通用算法 V 能够判断任意一个算术命题是否为真”矛盾。

因此，假设不成立。如果 T 是一致的，那么 T 一定是不完备的，即存在某个算术命题，既不能被证明为真，也不能被证明为假。

<br>

#### 7. 第一不完备性定理的另一种证明

**只要公理体系 T 是一致的，总存在⼀个算术命题，它是真的，但不能证明出来。**

首先，定义一个函数 sub(a,b,c)。此函数的作用是：取哥德尔数为 a 的命题，找到命题中哥德尔数为 c 的符号的位置，把它替换成数字 b ，计算并返回新命题的哥德尔数。

<br>

考虑此命题：“无法证明哥德尔数是 sub(y,y,17) 的命题”，设此命题的哥德尔数为 n 。

想要知道“哥德尔数是 sub(y,y,17) 的命题”是什么：

首先，取哥德尔数为 y 的命题。假设以 y 为哥德尔数的命题为 (∃x)(x=Sy)，则 y 的值为1722255...0000000（见附录）。

在此命题中，找到哥德尔数为 17 的符号（即 “y” 符号），并将其替换为 1722255...0000000 ，得到新的命题：(∃x)(x=s1722255...0000000)

那么，以 sub(y,y,17) 为哥德尔数的命题就是 (∃x)(x=s1722255...0000000)

<br>

现在，考虑此命题：“无法证明哥德尔数是 sub(n,n,17) 的命题”，记此命题为 G。

想要知道“哥德尔数是 sub(n,n,17) 的命题”是什么，首先，取哥德尔数为 n 的命题，即 “无法证明哥德尔数是 sub(y,y,17) 的命题”。

然后，找到哥德尔数为 17 的符号，并将其替换为 n ，得到新的命题：“无法证明哥德尔数是 sub(n,n,17) 的命题”，即 G 命题本身。

如此，我们通过复杂（且非常抽象）的方式，构造了一个命题 G，其在描述自己。

<br>

假如 G命题 是一个假命题，则说明 可以证明哥德尔数是 sub(n,n,17) 的命题，所以哥德尔数是sub(n,n,17)的命题是一个真命题，即“无法证明哥德尔数是sub(n,n,17)的命题”是一个真命题，与原假设矛盾。

所以，如果承认皮亚诺算术公理系统是一致的，那么 G 命题就只能是一个真命题。

但由于它说自己是无法证明的，所以这就是一个无法被证明出来的真命题。存在⼀个命题 G ，它是真的，但不能证明出来。

<br>

### 第二不完备性定理的证明

**只要公理体系 T 是一致的，就不可能在 T 内部证明 T 的一致性。**

证明如下：

第一不完备性定理证明了：如果 公理体系 T 是一致的，那就一定找不到 G 命题的证明。此时，由于 G 命题说自己是无法证明的，所以 G 命题为真。即，“T 是一致的” 证明了 G 命题。

假设 在 T 内部能证明 T 是一致的，那么在 T 内部就能证明 G 命题，这就与第一不完备性定理矛盾。

所以，在 T 内部不能证明 T 是一致的。即，只要公理体系 T 是一致的，就不可能在 T 内部证明 T 的一致性。

<br>

---

### 附录1：程序N(Y)的代码化表述

```python
def N(Y):
    if U(Y, Y) == False:  # 如果通用算法 U 判断 Y(Y) 不会停机
        return True  # 则 N(Y) 停机
    else:
        while True:  # 否则进入死循环
            pass
```

<br>

### 附录2：y的值

假设以 y 为哥德尔数的命题为 (∃x)(x=Sy)

则 y = 2^8 * 3^4 * 5^13 * 7^9 * 11^8 * 13^13 * 17^5 * 19^7 * 23^17 * 29^19

y 的值为：

172225505803959398742621651659678877886965404082311908389214945877004912002249920215937500000000。